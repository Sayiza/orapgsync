pipeline {
    agent any

    options {
        timeout(time: 12, unit: 'HOURS')
        disableConcurrentBuilds()
    }

    environment {
        PG_CONTAINER_NAME = 'pgtest'
        PG_PASSWORD       = 'secret'
        APP_PORT          = '8067'
        QUARKUS_LOG       = 'quarkus-app.log'

        // Oracle credentials (configured in Jenkins: Manage Jenkins → Credentials)
        ORACLE_URL      = credentials('oracle-url')
        ORACLE_USER     = credentials('oracle-user')
        ORACLE_PASSWORD = credentials('oracle-password')
    }

    stages {
        stage('Checkout') {
            steps {
                git url: 'https://github.com/Sayiza/orapgsync.git',
                    branch: 'main'
            }
        }

        stage('Start PostgreSQL') {
            steps {
                sh '''
                    # No pre-cleanup anymore — assuming previous run cleaned up
                    # If container still exists → docker run will fail (good for noticing issues)

                    # Failsafe removal of any previous container (won't fail build if missing)
                    docker rm -f ${PG_CONTAINER_NAME} || true

                    docker run --name ${PG_CONTAINER_NAME} \
                        -e POSTGRES_PASSWORD=${PG_PASSWORD} \
                        -e PGDATA=/var/lib/postgresql/pgdata \
                        -p 5432:5432 \
                        -d postgres

                    for i in {1..30}; do
                        if docker exec ${PG_CONTAINER_NAME} pg_isready -U postgres; then
                            echo "PostgreSQL is ready on localhost:5432"
                            break
                        fi
                        echo "Waiting for PostgreSQL... attempt $i/30"
                        sleep 3
                    done

                    docker exec ${PG_CONTAINER_NAME} pg_isready -U postgres || {
                        echo "ERROR: PostgreSQL failed to start"
                        docker logs ${PG_CONTAINER_NAME}
                        exit 1
                    }
                '''
            }
        }

        stage('Build & Test') {
            steps {
                withMaven(maven: 'Maven-3') {          // ← use your actual Maven tool name
                    sh 'mvn clean install'
                }
            }
        }

        stage('Init: Config & Connection Tests') {
            steps {
                sh '''
                    echo "Starting Quarkus application on port ${APP_PORT} ..."

                    # Start in background
                    nohup java \
                        -Dquarkus.http.port=${APP_PORT} \
                        -jar target/quarkus-app/quarkus-run.jar > ${QUARKUS_LOG} 2>&1 &

                    APP_PID=$!
                    echo $APP_PID > app.pid

                    echo "Waiting 60 seconds for application startup and initialization..."
                    sleep 60

                    echo "=== Checking if application process is still running ==="
                    ps -p $APP_PID -o pid= || echo "WARNING: Process already dead"

                    echo "=== Last 60 lines of application log ==="
                    tail -n 60 ${QUARKUS_LOG} || echo "Log file empty or missing"

                    # ── Send Configuration ───────────────────────────────────────────────────
                    echo "Sending configuration to http://localhost:${APP_PORT}/api/config ..."

                    RESPONSE=$(curl -s -o response.json -w "%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/config" \
                        -H 'Content-Type: application/json' \
                        --data-raw '{
                            "do.all-schemas": false,
                            "do.only-test-schema": "exampleschema,userschema2",
                            "oracle.url": "'"${ORACLE_URL}"'",
                            "oracle.user": "'"${ORACLE_USER}"'",
                            "oracle.password": "'"${ORACLE_PASSWORD}"'",
                            "java.generated-package-name": "me.christianrobert.ora2pgsync.autogen",
                            "path.target-project-java": "/src/main/java",
                            "path.target-project-resources": "/src/main/resources",
                            "path.target-project-postgre": "/postgre/autoddl",
                            "postgre.url": "jdbc:postgresql://localhost:5432/postgres",
                            "postgre.username": "postgres",
                            "postgre.password": "secret"
                        }')

                    echo "HTTP response code: $RESPONSE"

                    if [ "$RESPONSE" -ge 200 ] && [ "$RESPONSE" -lt 300 ]; then
                        echo "SUCCESS: Configuration accepted (HTTP $RESPONSE)"
                        cat response.json || echo "No response body"
                    else
                        echo "ERROR: Configuration failed (HTTP $RESPONSE)"
                        cat response.json || echo "No response body"
                        tail -n 100 ${QUARKUS_LOG}
                        exit 1
                    fi

                    sleep 5

                    # ── Oracle connection test ───────────────────────────────────────────────
                    echo "Testing Oracle connection..."
                    ORACLE_HTTP=$(curl -s -o oracle_test.json -w "%{http_code}" \
                        "http://localhost:${APP_PORT}/api/database/test/oracle")

                    echo "Oracle test HTTP status: $ORACLE_HTTP"

                    if [ "$ORACLE_HTTP" -ge 200 ] && [ "$ORACLE_HTTP" -lt 300 ]; then
                        echo "SUCCESS: Oracle connection test passed"
                        cat oracle_test.json || echo "(no response body)"
                    else
                        echo "ERROR: Oracle connection test failed (HTTP $ORACLE_HTTP)"
                        cat oracle_test.json || echo "(no response body)"
                        tail -n 60 ${QUARKUS_LOG}
                        exit 1
                    fi

                    # ── PostgreSQL connection test ───────────────────────────────────────────
                    echo "Testing PostgreSQL connection..."
                    PG_HTTP=$(curl -s -o pg_test.json -w "%{http_code}" \
                        "http://localhost:${APP_PORT}/api/database/test/postgres")

                    echo "PostgreSQL test HTTP status: $PG_HTTP"

                    if [ "$PG_HTTP" -ge 200 ] && [ "$PG_HTTP" -lt 300 ]; then
                        echo "SUCCESS: PostgreSQL connection test passed"
                        cat pg_test.json || echo "(no response body)"
                    else
                        echo "ERROR: PostgreSQL connection test failed (HTTP $PG_HTTP)"
                        cat pg_test.json || echo "(no response body)"
                        tail -n 60 ${QUARKUS_LOG}
                        exit 1
                    fi

                    echo "Init phase completed: Config loaded, both connections verified."
                '''
            }
        }
        stage('Schemas and Synonyms') {
            steps {
                sh '''
                    set -eu # fail fast on errors

                    # ══════════════════════════════════════════════════════════════════════════
                    # SCHEMA EXTRACTION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo "Starting Oracle schema extraction job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/schemas/oracle/extract" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start schema extraction job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Extraction job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 60 attempts = ~10 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=60

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Schema Extract $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Schema extraction completed"
                                break
                            else
                                echo "ERROR: Extraction job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Extraction job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Extraction timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    # ══════════════════════════════════════════════════════════════════════════
                    # SCHEMA CREATION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo ""
                    echo "Starting PostgreSQL schema creation job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/schemas/postgres/create" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start schema creation job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Creation job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 60 attempts = ~10 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=60

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Schema Create $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Schema creation completed"
                                break
                            else
                                echo "ERROR: Creation job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Creation job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Creation timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    # ══════════════════════════════════════════════════════════════════════════
                    # SYNONYM EXTRACTION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo ""
                    echo "Starting Oracle synonym extraction job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/transfer/oracle/synonyms" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start synonym extraction job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Synonym extraction job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 60 attempts = ~10 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=60

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Synonym Extract $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Synonym extraction completed"
                                break
                            else
                                echo "ERROR: Synonym extraction job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Synonym extraction job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Synonym extraction timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    echo ""
                    echo "Schemas and Synonyms stage completed successfully."
                '''
            }
        }

        stage('Object Types: Extract & Create') {
            steps {
                sh '''
                    set -eu # fail fast on errors

                    # ══════════════════════════════════════════════════════════════════════════
                    # OBJECT TYPE EXTRACTION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo "Starting Oracle object type extraction job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/objects/oracle/extract" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start object type extraction job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Object type extraction job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 60 attempts = ~10 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=60

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "ObjType Extract $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Object type extraction completed"
                                break
                            else
                                echo "ERROR: Object type extraction job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Object type extraction job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Object type extraction timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    # ══════════════════════════════════════════════════════════════════════════
                    # OBJECT TYPE CREATION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo ""
                    echo "Starting PostgreSQL object type creation job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/objects/postgres/create" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start object type creation job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Object type creation job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 60 attempts = ~10 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=60

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "ObjType Create $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Object type creation completed"
                                break
                            else
                                echo "ERROR: Object type creation job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Object type creation job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Object type creation timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    echo ""
                    echo "Object Types stage completed successfully."
                '''
            }
        }

        stage('Sequences: Extract & Create') {
            steps {
                sh '''
                    set -eu # fail fast on errors

                    # ══════════════════════════════════════════════════════════════════════════
                    # SEQUENCE EXTRACTION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo "Starting Oracle sequence extraction job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/sequences/oracle/extract" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start sequence extraction job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Sequence extraction job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 60 attempts = ~10 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=60

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Seq Extract $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Sequence extraction completed"
                                break
                            else
                                echo "ERROR: Sequence extraction job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Sequence extraction job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Sequence extraction timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    # ══════════════════════════════════════════════════════════════════════════
                    # SEQUENCE CREATION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo ""
                    echo "Starting PostgreSQL sequence creation job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/sequences/postgres/create" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start sequence creation job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Sequence creation job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 60 attempts = ~10 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=60

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Seq Create $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Sequence creation completed"
                                break
                            else
                                echo "ERROR: Sequence creation job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Sequence creation job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Sequence creation timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    echo ""
                    echo "Sequences stage completed successfully."
                '''
            }
        }

        stage('Tables: Extract & Create') {
            steps {
                sh '''
                    set -eu # fail fast on errors

                    # ══════════════════════════════════════════════════════════════════════════
                    # TABLE EXTRACTION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo "Starting Oracle table extraction job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/tables/oracle/extract" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start table extraction job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Table extraction job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 120 attempts = ~20 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=120

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Table Extract $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Table extraction completed"
                                break
                            else
                                echo "ERROR: Table extraction job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Table extraction job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Table extraction timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    # ══════════════════════════════════════════════════════════════════════════
                    # TABLE CREATION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo ""
                    echo "Starting PostgreSQL table creation job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/tables/postgres/create" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start table creation job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Table creation job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 240 attempts = ~40 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=240

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Table Create $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Table creation completed"
                                break
                            else
                                echo "ERROR: Table creation job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Table creation job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Table creation timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    echo ""
                    echo "Tables stage completed successfully."
                '''
            }
        }

        stage('Data Transfer') {
            steps {
                sh '''
                    set -eu # fail fast on errors

                    # ══════════════════════════════════════════════════════════════════════════
                    # DATA TRANSFER (Oracle → PostgreSQL)
                    # ══════════════════════════════════════════════════════════════════════════
                    echo "Starting data transfer job (Oracle → PostgreSQL)..."
                    echo "NOTE: This can take up to 8 hours for large datasets"

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/transfer/postgres/execute" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start data transfer job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Data transfer job started. Job ID: $JOB_ID"
                    echo "Polling status every 20 seconds (max 1440 attempts = ~8 hours)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=1440

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Data Transfer $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Data transfer completed"
                                break
                            else
                                echo "ERROR: Data transfer job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Data transfer job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 20
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Data transfer timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    echo ""
                    echo "Data Transfer stage completed successfully."
                '''
            }
        }

        stage('Constraints and Indexes') {
            steps {
                sh '''
                    set -eu # fail fast on errors

                    # ══════════════════════════════════════════════════════════════════════════
                    # CONSTRAINT CREATION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo "Starting PostgreSQL constraint creation job..."
                    echo "Creating constraints in dependency order: PK → UK → FK → CHECK"

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/constraints/postgres/create" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start constraint creation job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Constraint creation job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 360 attempts = ~60 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=360

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Constraint Create $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Constraint creation completed"
                                break
                            else
                                echo "ERROR: Constraint creation job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Constraint creation job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Constraint creation timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    # ══════════════════════════════════════════════════════════════════════════
                    # FK INDEX CREATION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo ""
                    echo "Starting PostgreSQL FK index creation job..."
                    echo "Creating indexes on foreign key columns for query performance"

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/constraints/postgres/fk-indexes/create" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start FK index creation job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "FK index creation job started. Job ID: $JOB_ID"
                    echo "Polling status every 10 seconds (max 120 attempts = ~20 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=120

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "FK Index Create $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: FK index creation completed"
                                break
                            else
                                echo "ERROR: FK index creation job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: FK index creation job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 10
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: FK index creation timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    echo ""
                    echo "Constraints and Indexes stage completed successfully."
                '''
            }
        }

        stage('Views and Synonyms') {
            steps {
                sh '''
                    set -eu # fail fast on errors

                    # ══════════════════════════════════════════════════════════════════════════
                    # VIEW EXTRACTION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo "Starting Oracle view extraction job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/views/oracle/extract" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start view extraction job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "View extraction job started. Job ID: $JOB_ID"
                    echo "Polling status every 20 seconds (max 120 attempts = ~40 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=120

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "View Extract $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: View extraction completed"
                                break
                            else
                                echo "ERROR: View extraction job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: View extraction job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 20
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: View extraction timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    # ══════════════════════════════════════════════════════════════════════════
                    # VIEW STUB CREATION
                    # ══════════════════════════════════════════════════════════════════════════
                    echo ""
                    echo "Starting PostgreSQL view stub creation job..."

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/views/postgres/stubs/create" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start view stub creation job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "View stub creation job started. Job ID: $JOB_ID"
                    echo "Polling status every 20 seconds (max 120 attempts = ~40 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=120

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "View Stub Create $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: View stub creation completed"
                                break
                            else
                                echo "ERROR: View stub creation job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: View stub creation job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 20
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: View stub creation timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    # ══════════════════════════════════════════════════════════════════════════
                    # VIEW IMPLEMENTATION (Full SQL transformation)
                    # ══════════════════════════════════════════════════════════════════════════
                    echo ""
                    echo "Starting PostgreSQL view implementation job..."
                    echo "Transforming Oracle view SQL to PostgreSQL"

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/views/postgres/implementation/create" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start view implementation job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "View implementation job started. Job ID: $JOB_ID"
                    echo "Polling status every 20 seconds (max 240 attempts = ~80 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=240

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "View Impl $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: View implementation completed"
                                break
                            else
                                echo "ERROR: View implementation job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: View implementation job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 20
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: View implementation timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    # ══════════════════════════════════════════════════════════════════════════
                    # SYNONYM REPLACEMENT VIEWS
                    # ══════════════════════════════════════════════════════════════════════════
                    echo ""
                    echo "Starting PostgreSQL synonym replacement view creation job..."
                    echo "Creating views to emulate Oracle synonym behavior"

                    RESPONSE=$(curl -s -w "\\n%{http_code}" \
                        -X POST "http://localhost:${APP_PORT}/api/synonyms/postgres/replacement-views/create" \
                        -H 'Content-Type: application/json')

                    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                    BODY=$(echo "$RESPONSE" | head -n-1)

                    echo "Start request HTTP code: $HTTP_CODE"

                    if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
                        echo "ERROR: Failed to start synonym replacement view creation job"
                        echo "$BODY"
                        exit 1
                    fi

                    JOB_ID=$(echo "$BODY" | jq -r '.jobId // empty')

                    if [ -z "$JOB_ID" ]; then
                        echo "ERROR: No jobId found in response"
                        echo "$BODY"
                        exit 1
                    fi

                    echo "Synonym replacement view creation job started. Job ID: $JOB_ID"
                    echo "Polling status every 20 seconds (max 120 attempts = ~40 min)"

                    ATTEMPT=0
                    MAX_ATTEMPTS=120

                    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                        ATTEMPT=$((ATTEMPT + 1))

                        STATUS_RESP=$(curl -s "http://localhost:${APP_PORT}/api/jobs/${JOB_ID}/status")

                        STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "UNKNOWN"')
                        IS_COMPLETE=$(echo "$STATUS_RESP" | jq -r '.isComplete // "false"')
                        PERCENTAGE=$(echo "$STATUS_RESP" | jq -r '.progress.percentage // 0')
                        DETAILS=$(echo "$STATUS_RESP" | jq -r '.progress.details // "No details"')

                        echo "Synonym Views $ATTEMPT/$MAX_ATTEMPTS | Status: $STATUS | $PERCENTAGE% | $DETAILS"

                        if [ "$IS_COMPLETE" = "true" ]; then
                            if [ "$STATUS" = "COMPLETED" ]; then
                                echo "SUCCESS: Synonym replacement view creation completed"
                                break
                            else
                                echo "ERROR: Synonym replacement view creation job finished with status: $STATUS"
                                echo "$STATUS_RESP"
                                exit 1
                            fi
                        fi

                        if [ "$STATUS" = "FAILED" ] || [ "$STATUS" = "ERROR" ] || [ "$STATUS" = "CANCELLED" ]; then
                            echo "ERROR: Synonym replacement view creation job entered failure state: $STATUS"
                            echo "$STATUS_RESP"
                            exit 1
                        fi

                        sleep 20
                    done

                    if [ "$IS_COMPLETE" != "true" ]; then
                        echo "ERROR: Synonym replacement view creation timeout after $MAX_ATTEMPTS attempts"
                        echo "$STATUS_RESP"
                        exit 1
                    fi

                    echo ""
                    echo "Views and Synonyms stage completed successfully."
                '''
            }
        }
    }

    post {
        always {
            // Automatic cleanup

            sh '''
                # Stop Quarkus app if PID file exists
                if [ -f app.pid ]; then
                    kill $(cat app.pid) || true
                    rm -f app.pid
                fi
                # Optional: remove log too (or keep for next run debugging)
                # rm -f ${QUARKUS_LOG}
            '''

            archiveArtifacts artifacts: '*.log, app.pid',
                           allowEmptyArchive: true,
                           fingerprint: true

            echo """
╔════════════════════════════════════════════════════════════════════════════╗
║                         BUILD COMPLETED — CLEANUP PERFORMED                ║
╚════════════════════════════════════════════════════════════════════════════╝

PostgreSQL container '${PG_CONTAINER_NAME}' was left running for manual review.
Quarkus application (port ${APP_PORT}) has been terminated.

Logs and PID file (if any) have been archived as build artifacts.

Next run will remove the old container and start fresh.
            """
        }

        success {
            echo "SUCCESS — build, smoke test, and cleanup completed."
        }

        failure {
            echo "Build failed — cleanup was still attempted."
            echo "Check console and archived logs if needed."
        }
    }
}